<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>05 - 实现 readonly 功能</title>
    <link href="/2022/03/13/5.%20%E5%AE%9E%E7%8E%B0%20readonly%20%E5%8A%9F%E8%83%BD/"/>
    <url>/2022/03/13/5.%20%E5%AE%9E%E7%8E%B0%20readonly%20%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="实现-readonly-功能"><a href="#实现-readonly-功能" class="headerlink" title="实现 readonly 功能"></a>实现 readonly 功能</h1><p>在本小节中，我们将会实现 readonly API</p><h2 id="1-happy-path-单元测试"><a href="#1-happy-path-单元测试" class="headerlink" title="1. happy path 单元测试"></a>1. happy path 单元测试</h2><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;happy path&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// not set</span><br>    <span class="hljs-keyword">const</span> original = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;<br>    <span class="hljs-keyword">const</span> wrapped = <span class="hljs-title function_">readonly</span>(original)<br>    <span class="hljs-title function_">expect</span>(wrapped).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBe</span>(original)<br>    <span class="hljs-title function_">expect</span>(wrapped.<span class="hljs-property">bar</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>)<br>    wrapped.<span class="hljs-property">foo</span> = <span class="hljs-number">2</span><br>    <span class="hljs-comment">// set 后不会更改</span><br>    <span class="hljs-title function_">expect</span>(wrapped.<span class="hljs-property">foo</span>).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-实现-happy-path"><a href="#2-实现-happy-path" class="headerlink" title="2. 实现 happy path"></a>2. 实现 happy path</h2><p>我们知道 readonly 和 reactive 的实现原理是一致的，都可以通过 Proxy 来实现一个包装类，唯一的区别在于，readonly 的不会被 track，而且 readonly 的属性值不可更改</p><p>那么该如何实现呢？</p><h3 id="2-1-v1"><a href="#2-1-v1" class="headerlink" title="2.1 v1"></a>2.1 v1</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// reactive.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span>(<span class="hljs-params">raw</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, &#123;<br>        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>            <span class="hljs-keyword">return</span> res<br>        &#125;,<br>        <span class="hljs-title function_">set</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个版本下，我们就实现了最简单的 readonly 的实现。但是我们可以发现其实 reactive 和 readonly 的部分代码是一样的，就可以提取重复代码变为函数：</p><h3 id="2-2-v2"><a href="#2-2-v2" class="headerlink" title="2.2 v2"></a>2.2 v2</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; track, trigger &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./effect&#x27;</span><br><br><br><span class="hljs-comment">// version 2 版本就可以将重复的代码提取出来</span><br><span class="hljs-comment">// 作为 createGetter 和 createSetter</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createGetter</span>(<span class="hljs-params">isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>    <span class="hljs-keyword">if</span> (!isReadonly) &#123;<br>      <span class="hljs-title function_">track</span>(target, key)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSetter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)<br>    <span class="hljs-title function_">trigger</span>(target, key)<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">raw</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-title function_">createGetter</span>(),<br>    <span class="hljs-attr">set</span>: <span class="hljs-title function_">createSetter</span>(),<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span>(<span class="hljs-params">raw</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-title function_">createGetter</span>(<span class="hljs-literal">true</span>),<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;,<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更好的管理代码，在 v3 中，我们还可以直接将 createSetter 和 createGetter 分层出去</p><h3 id="2-3-v3"><a href="#2-3-v3" class="headerlink" title="2.3 v3"></a>2.3 v3</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// reactivity/baseHandlers.ts</span><br><span class="hljs-keyword">import</span> &#123; track, trigger &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./effect&#x27;</span><br><br><span class="hljs-keyword">const</span> get = <span class="hljs-title function_">createGetter</span>()<br><span class="hljs-keyword">const</span> readonlyGet = <span class="hljs-title function_">createGetter</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">const</span> set = <span class="hljs-title function_">createSetter</span>()<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createGetter</span>(<span class="hljs-params">isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>    <span class="hljs-comment">// 在 get 时收集依赖</span><br>    <span class="hljs-keyword">if</span> (!isReadonly) &#123;<br>      <span class="hljs-title function_">track</span>(target, key)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createSetter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)<br>    <span class="hljs-comment">// 在 set 时触发依赖</span><br>    <span class="hljs-title function_">trigger</span>(target, key)<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// mutable 可变的</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mutableHandlers = &#123;<br>  get,<br>  set,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> readonlyHandlers = &#123;<br>  <span class="hljs-attr">get</span>: readonlyGet,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;,<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; mutableHandlers, readonlyHandlers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./baseHandlers&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">raw</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, mutableHandlers)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span>(<span class="hljs-params">raw</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, readonlyHandlers)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以将实现与入口分离开来了。下面我们看到其实 reactive 和 readonly 它的创建方式是差不多的都是通过 new Proxy 的方式来创建，那么这些步骤我们也可以来分离开</p><h3 id="2-4-v4"><a href="#2-4-v4" class="headerlink" title="2.4 v4"></a>2.4 v4</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// reactive.ts</span><br><br><span class="hljs-keyword">import</span> &#123; mutableHandlers, readonlyHandlers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./baseHandlers&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createActiveObject</span>(<span class="hljs-params">raw, baseHandlers</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, baseHandlers)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">raw</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createActiveObject</span>(raw, mutableHandlers)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span>(<span class="hljs-params">raw</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createActiveObject</span>(raw, readonlyHandlers)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就实现了最少的代码了</p><h2 id="3-警告特性单元测试"><a href="#3-警告特性单元测试" class="headerlink" title="3. 警告特性单元测试"></a>3. 警告特性单元测试</h2><p>这个单元测试，我们要让用户在设置一个 readonly prop value 时报一个警告</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;should warn when update readonly prop value&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 这里使用 jest.fn</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-property">warn</span> = jest.<span class="hljs-title function_">fn</span>()<br>    <span class="hljs-keyword">const</span> readonlyObj = <span class="hljs-title function_">readonly</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;)<br>    readonlyObj.<span class="hljs-property">foo</span> = <span class="hljs-number">2</span><br>    <span class="hljs-title function_">expect</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">warn</span>).<span class="hljs-title function_">toHaveBeenCalled</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="4-实现警告特性"><a href="#4-实现警告特性" class="headerlink" title="4. 实现警告特性"></a>4. 实现警告特性</h2><p>这里我们发现实现警告还是非常简单的，只需要找到 readonly proxy 的 set 即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// baseHandlers.ts</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> readonlyHandlers = &#123;<br>  get,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) &#123;<br>    <span class="hljs-comment">// 在这里警告</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<br>      <span class="hljs-string">`key: <span class="hljs-subst">$&#123;key&#125;</span> set value: <span class="hljs-subst">$&#123;value&#125;</span> fail, because the target is readonly`</span>,<br>      target<br>    )<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候我们再跑一边测试，发现就完全没问题了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>04 - 实现 effect 的 stop 功能</title>
    <link href="/2022/03/12/4.%20%E5%AE%9E%E7%8E%B0%20effect%20%E7%9A%84%20stop%20%E5%8A%9F%E8%83%BD/"/>
    <url>/2022/03/12/4.%20%E5%AE%9E%E7%8E%B0%20effect%20%E7%9A%84%20stop%20%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="实现-effect-的-stop-功能"><a href="#实现-effect-的-stop-功能" class="headerlink" title="实现 effect 的 stop 功能"></a>实现 effect 的 stop 功能</h1><p>在本小节中，我们去实现 effect 的 stop 功能</p><h2 id="1-stop-的测试样例"><a href="#1-stop-的测试样例" class="headerlink" title="1. stop 的测试样例"></a>1. stop 的测试样例</h2><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;stop&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> dummy<br>    <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">prop</span>: <span class="hljs-number">1</span> &#125;)<br>    <span class="hljs-keyword">const</span> runner = <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        dummy = obj.<span class="hljs-property">prop</span><br>    &#125;)<br>    obj.<span class="hljs-property">prop</span> = <span class="hljs-number">2</span><br>    <span class="hljs-title function_">expect</span>(dummy).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-comment">// stop 一个 runner 之后</span><br>    <span class="hljs-title function_">stop</span>(runner)<br>    obj.<span class="hljs-property">prop</span>++<br>    <span class="hljs-comment">// 依赖再次更新，当时传入的 effect 则不会重新执行</span><br>    <span class="hljs-title function_">expect</span>(dummy).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-comment">// runner 不受到影响</span><br>    <span class="hljs-title function_">runner</span>()<br>    <span class="hljs-title function_">expect</span>(dummy).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">3</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>通过一个测试样例，我们发现其实也是非常简单的</p><h2 id="2-实现-stop"><a href="#2-实现-stop" class="headerlink" title="2. 实现 stop"></a>2. 实现 stop</h2><p>首先，我们知道所有的 effect 存在 deps 中，也就是我们的 effects 是在 <code>track</code> 方法进行保存的，那么如果不想让这个 effect 执行，就可以找到 target - key 对应的 deps 中，删除掉我们的 effect 即可。</p><p>首先，我们在 ReactiveEffect 实例中去记录我们反向对应的 deps</p><h3 id="2-1-v1"><a href="#2-1-v1" class="headerlink" title="2.1 v1"></a>2.1 v1</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// effect.ts</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> &#123;<br>  <span class="hljs-comment">// [stop] 反向记录自己对应的 dep 那个 set</span><br>  deps = []<br>  <span class="hljs-comment">// other code</span><br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-comment">// other code ...</span><br>  dep.<span class="hljs-title function_">add</span>(activeEffect)<br>  <span class="hljs-comment">// [stop]：反向追踪 activeEffect 的 dep</span><br>  <span class="hljs-comment">// 因为一个 activeEffect 可能会对应多个 dep，每个 dep 是一个 set</span><br>  <span class="hljs-comment">// 这里我们可以使用一个数组</span><br>  activeEffect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们可以去实现一个 stop 的实例方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> &#123;<br>  <span class="hljs-comment">// other code ...</span><br>  <span class="hljs-comment">// [stop] 这个方法的作用就是去根据 this.deps 删除 this 对应的 effect</span><br>  <span class="hljs-title function_">stop</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">dep: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      dep.<span class="hljs-title function_">delete</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以去实现一个 stop 方法了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params">runner</span>) &#123;<br>  <span class="hljs-comment">// [stop] 如何获取到当前所属的 effect 实例呢？</span><br>  <span class="hljs-comment">// 这样就可以去调用 stop 方法了</span><br>  runner.<span class="hljs-property">effect</span>.<span class="hljs-title function_">stop</span>()<br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn, options: <span class="hljs-built_in">any</span> = &#123;&#125;</span>) &#123;<br>  <span class="hljs-comment">// other code</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">runner</span>: <span class="hljs-built_in">any</span> = _effect.<span class="hljs-property">run</span>.<span class="hljs-title function_">bind</span>(_effect)<br>  <span class="hljs-comment">// [stop] 在这里挂载一下所属的 effect</span><br>  runner.<span class="hljs-property">effect</span> = _effect<br>  <span class="hljs-keyword">return</span> runner<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-v2"><a href="#2-2-v2" class="headerlink" title="2.2 v2"></a>2.2 v2</h3><p>但是我们在运行完单测后会出现问题，这是因为如果使用上面的方法的话，会存在重复收集的问题，例如我们在 stop 后，此时所属的 effect 其实已经清空过了，但是下面我们又对依赖项进行了 getter，也就是 track，那么就会再次将所属的 track 收集起来，那么 stop 删除的元素就等于是重新就加回来了，所以我们需要修改一下代码，加一个状态；</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> &#123;<br>  <span class="hljs-comment">// [stop] 该 effect 是否调用过 stop 方法了</span><br>  <span class="hljs-comment">// true 未调用 false 调用</span><br>  active = <span class="hljs-literal">true</span><br><br>  <span class="hljs-title function_">stop</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 如果没调用这个方法，去清空所属的 effect</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">dep: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>        dep.<span class="hljs-title function_">delete</span>(<span class="hljs-variable language_">this</span>)<br>      &#125;)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">active</span> = <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// track 的代码也要改一下</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-comment">// 如果该 activeEffect 还没有调用 stop 方法的时候，再去添加依赖和反向收集依赖</span><br>  <span class="hljs-keyword">if</span> (activeEffect.<span class="hljs-property">active</span>) &#123;<br>    activeEffect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep)<br>    dep.<span class="hljs-title function_">add</span>(activeEffect)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们再去运行单元测试发现就没问题了</p><p>后面我们就可以去优化了，例如将删除依赖的函数作为单独的函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> &#123;<br>  <span class="hljs-title function_">stop</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">cleanupEffect</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 把清除的逻辑单独作为函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanupEffect</span>(<span class="hljs-params">effect</span>) &#123;<br>  <span class="hljs-keyword">if</span> (effect.<span class="hljs-property">active</span>) &#123;<br>    effect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">dep: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      dep.<span class="hljs-title function_">delete</span>(effect)<br>    &#125;)<br>    effect.<span class="hljs-property">active</span> = <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-onStop-的测试样例"><a href="#3-onStop-的测试样例" class="headerlink" title="3. onStop 的测试样例"></a>3. onStop 的测试样例</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;onStop&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123;<br>        <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>    &#125;)<br>    <span class="hljs-keyword">const</span> onStop = jest.<span class="hljs-title function_">fn</span>()<br>    <span class="hljs-keyword">let</span> dummy<br>    <span class="hljs-comment">// onStop 是一个函数，也是 effect 的 option</span><br>    <span class="hljs-keyword">const</span> runner = <span class="hljs-title function_">effect</span>(<br>        <span class="hljs-function">() =&gt;</span> &#123;<br>            dummy = obj.<span class="hljs-property">foo</span><br>        &#125;,<br>        &#123;<br>            onStop,<br>        &#125;<br>    )<br>    <span class="hljs-comment">// 在调用 stop 的时候，onStop 也会执行</span><br>    <span class="hljs-title function_">stop</span>(runner)<br>    <span class="hljs-title function_">expect</span>(onStop).<span class="hljs-title function_">toBeCalledTimes</span>(<span class="hljs-number">1</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="4-实现-onStop"><a href="#4-实现-onStop" class="headerlink" title="4. 实现 onStop"></a>4. 实现 onStop</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn, options: <span class="hljs-built_in">any</span> = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> _effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn, options)<br>  <span class="hljs-comment">// [stop] 这里我们 options 会接收一个 onStop 方法</span><br>  <span class="hljs-comment">// 其实我们可以将 options 中的所有数据全部挂载在 effect 上面</span><br>  <span class="hljs-comment">// extend = Object.assign 封装一下是为了语义化更好</span><br>  <span class="hljs-title function_">extend</span>(_effect, options)<br>  <span class="hljs-comment">// other code ...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// ./src/shared/index.ts</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> extend = <span class="hljs-title class_">Object</span>.<span class="hljs-property">assign</span><br></code></pre></td></tr></table></figure><p>今后该项目中全局可用的工具函数可以放在 <code>shared</code> 目录下，这个也是为了与 <code>Vue</code> 的开发方式贴近</p><p>然后在清除的函数中去判断并执行</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanupEffect</span>(<span class="hljs-params">effect</span>) &#123;<br>  <span class="hljs-keyword">if</span> (effect.<span class="hljs-property">active</span>) &#123;<br>    effect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">dep: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      dep.<span class="hljs-title function_">delete</span>(effect)<br>    &#125;)<br>    <span class="hljs-comment">// [onStop] 如果存在 onStop，就去运行 onStop</span><br>    <span class="hljs-keyword">if</span> (effect.<span class="hljs-property">onStop</span>) effect.<span class="hljs-title function_">onStop</span>()<br>    effect.<span class="hljs-property">active</span> = <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>跑一下测试，发现也是可以通过的</p><h2 id="5-修复-happy-path-bug"><a href="#5-修复-happy-path-bug" class="headerlink" title="5. 修复 happy path bug"></a>5. 修复 happy path bug</h2><p>这个时候我们再全局跑一下所有测试，发现在 <code>effect</code> 的 happy path 中出现了错误</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-comment">// 这一行找不到 activeEffect</span><br>  <span class="hljs-keyword">if</span> (activeEffect.<span class="hljs-property">active</span>) &#123;<br>    activeEffect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep)<br>    dep.<span class="hljs-title function_">add</span>(activeEffect)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改成下面这样就可以了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (activeEffec &amp;&amp; activeEffect.<span class="hljs-property">active</span>) &#123;<br>    activeEffect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep)<br>    dep.<span class="hljs-title function_">add</span>(activeEffect)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>03 - 实现 effect 的 scheduler 功能</title>
    <link href="/2022/03/12/3.%20%E5%AE%9E%E7%8E%B0%20effect%20%E7%9A%84%20scheduler%20%E5%8A%9F%E8%83%BD/"/>
    <url>/2022/03/12/3.%20%E5%AE%9E%E7%8E%B0%20effect%20%E7%9A%84%20scheduler%20%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="实现-effect-的-scheduler-功能"><a href="#实现-effect-的-scheduler-功能" class="headerlink" title="实现 effect 的 scheduler 功能"></a>实现 effect 的 scheduler 功能</h1><p>在本小节中，我们将会实现 effect 的 scheduler 功能</p><h2 id="1-测试样例"><a href="#1-测试样例" class="headerlink" title="1. 测试样例"></a>1. 测试样例</h2><p>我们先来看看测试样例</p><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;scheduler&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 1. scheduler 作为 effect 的一个 option</span><br>    <span class="hljs-comment">// 2. 有了 scheduler 之后原来的 fn 参数只会执行初始化的一次</span><br>    <span class="hljs-comment">// 3. 如果依赖更新时不会执行 fn ，而是会去执行 scheduler</span><br>    <span class="hljs-comment">// 4. runner 不受影响</span><br>    <span class="hljs-keyword">let</span> dummy<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">run</span>: <span class="hljs-built_in">any</span><br>    <span class="hljs-keyword">const</span> scheduler = jest.<span class="hljs-title function_">fn</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        run = runner<br>    &#125;)<br>    <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;)<br>    <span class="hljs-comment">// 在这里将 scheduler 作为一个 option 传入 effect</span><br>    <span class="hljs-keyword">const</span> runner = <span class="hljs-title function_">effect</span>(<br>        <span class="hljs-function">() =&gt;</span> &#123;<br>            dummy = obj.<span class="hljs-property">foo</span><br>        &#125;,<br>        &#123; scheduler &#125;<br>    )<br>    <span class="hljs-title function_">expect</span>(scheduler).<span class="hljs-property">not</span>.<span class="hljs-title function_">toHaveBeenCalled</span>()<br>    <span class="hljs-comment">// 会执行一次 effect 传入的 fn</span><br>    <span class="hljs-title function_">expect</span>(dummy).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>)<br>    obj.<span class="hljs-property">foo</span>++<br>    <span class="hljs-comment">// 有了 scheduler 之后，原来的 fn 就不会执行了</span><br>    <span class="hljs-title function_">expect</span>(scheduler).<span class="hljs-title function_">toHaveBeenCalledTimes</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-title function_">expect</span>(dummy).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-title function_">run</span>()<br>    <span class="hljs-title function_">expect</span>(dummy).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-实现-scheduler"><a href="#2-实现-scheduler" class="headerlink" title="2. 实现 scheduler"></a>2. 实现 scheduler</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">_fn</span>: <span class="hljs-built_in">any</span><br>  <span class="hljs-comment">// [scheduler] 构造函数加入 options，这里使用 public 可以供外部使用</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn, <span class="hljs-keyword">public</span> options</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fn</span> = fn<br>  &#125;<br>  <span class="hljs-comment">// other code ...</span><br>&#125;<br><br><span class="hljs-comment">// other code ...</span><br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">const</span> deps = depsMap.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> effect <span class="hljs-keyword">of</span> deps) &#123;<br>    <span class="hljs-comment">// [scheduler] 这里需要判断一下 scheduler，如果存在就去运行 scheduler 而不是 fn</span><br>    <span class="hljs-keyword">if</span> (effect.<span class="hljs-property">options</span>.<span class="hljs-property">scheduler</span>) &#123;<br>      effect.<span class="hljs-property">options</span>.<span class="hljs-title function_">scheduler</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      effect.<span class="hljs-title function_">run</span>()<br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn, options: <span class="hljs-built_in">any</span> = &#123;&#125;</span>) &#123;<br>  <span class="hljs-comment">// [scheduler]在创建 ReactiveEffect 实例的时候，保存一下 options</span><br>  <span class="hljs-keyword">const</span> _effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn, options)<br>  <span class="hljs-comment">// other code ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们再运行单元测试，就可以通过了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>02 - 实现 effect 返回 runner</title>
    <link href="/2022/03/12/2.%20%E5%AE%9E%E7%8E%B0%20effect%20%E8%BF%94%E5%9B%9E%20runner/"/>
    <url>/2022/03/12/2.%20%E5%AE%9E%E7%8E%B0%20effect%20%E8%BF%94%E5%9B%9E%20runner/</url>
    
    <content type="html"><![CDATA[<h1 id="实现-effect-返回-runner"><a href="#实现-effect-返回-runner" class="headerlink" title="实现 effect 返回 runner"></a>实现 effect 返回 runner</h1><p>在本小节中，我们将会实现 effect 返回 runner</p><h2 id="1-测试样例"><a href="#1-测试样例" class="headerlink" title="1. 测试样例"></a>1. 测试样例</h2><figure class="highlight ts"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;runner&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// runner 就是 effect(fn) 返回一个函数，执行该函数就相当于重新执行了一次传入 effect 的 fn</span><br>    <span class="hljs-comment">// 同时执行 runner 也会将 fn 的返回值返回</span><br>    <span class="hljs-keyword">let</span> foo = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> runner = <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        foo++<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span><br>    &#125;)<br>    <span class="hljs-title function_">expect</span>(foo).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-comment">// 调用 runner</span><br>    <span class="hljs-keyword">const</span> r = <span class="hljs-title function_">runner</span>()<br>    <span class="hljs-title function_">expect</span>(foo).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">3</span>)<br>    <span class="hljs-comment">// 获取 fn 返回的值</span><br>    <span class="hljs-title function_">expect</span>(r).<span class="hljs-title function_">toBe</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><p>这个该如何实现呢？其实也是非常简单的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// effect.ts</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">_fn</span>: <span class="hljs-built_in">any</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fn</span> = fn<br>  &#125;<br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    activeEffect = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_fn</span>()<br>    <span class="hljs-comment">// [runner] return 运行的值</span><br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// other code ...</span><br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> _effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn)<br>  _effect.<span class="hljs-title function_">run</span>()<br>  <span class="hljs-comment">// [runner]: 在这里将 run 方法 return 出去</span><br>  <span class="hljs-comment">// 但是要注意 this 指向问题，所以可以 bind 后 return 出去</span><br>  <span class="hljs-keyword">return</span> _effect.<span class="hljs-property">run</span>.<span class="hljs-title function_">bind</span>(_effect)<br>&#125;<br></code></pre></td></tr></table></figure><p>再次测试一下，测试样例就可以通过了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>01 - 实现 effect &amp; reactive &amp; 依赖收集 &amp; 触发依赖</title>
    <link href="/2022/03/12/1.%E5%AE%9E%E7%8E%B0%20effect%20&amp;%20reactive%20&amp;%20%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%20&amp;%20%E8%A7%A6%E5%8F%91%E4%BE%9D%E8%B5%96/"/>
    <url>/2022/03/12/1.%E5%AE%9E%E7%8E%B0%20effect%20&amp;%20reactive%20&amp;%20%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%20&amp;%20%E8%A7%A6%E5%8F%91%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h1 id="实现-effect-amp-reactive-amp-依赖收集-amp-触发依赖"><a href="#实现-effect-amp-reactive-amp-依赖收集-amp-触发依赖" class="headerlink" title="实现 effect &amp; reactive &amp; 依赖收集 &amp; 触发依赖"></a>实现 effect &amp; reactive &amp; 依赖收集 &amp; 触发依赖</h1><p>在本小节呢，我们将实现 effect &amp; reactive &amp; 依赖收集 &amp; 触发依赖</p><h2 id="1-编写单元测试"><a href="#1-编写单元测试" class="headerlink" title="1. 编写单元测试"></a>1. 编写单元测试</h2><p>我们先建一个单元测试：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;effect&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;happy path&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-title function_">reactive</span>(&#123;<br>      <span class="hljs-attr">age</span>: <span class="hljs-number">10</span>,<br>    &#125;)<br>    <span class="hljs-keyword">let</span> nextAge<br>    <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      nextAge = user.<span class="hljs-property">age</span> + <span class="hljs-number">1</span><br>    &#125;)<br>    <span class="hljs-title function_">expect</span>(nextAge).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">11</span>)<br><br>    <span class="hljs-comment">// update</span><br>    user.<span class="hljs-property">age</span>++<br>    <span class="hljs-title function_">expect</span>(nextAge).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">12</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>以上的单元测试，就是本文中重点需要通过的测试。在此之前，我们可以先去写一个 reactive API</p><h2 id="2-reactive-实现"><a href="#2-reactive-实现" class="headerlink" title="2. reactive 实现"></a>2. reactive 实现</h2><h3 id="2-1-编写一个单元测试"><a href="#2-1-编写一个单元测试" class="headerlink" title="2.1 编写一个单元测试"></a>2.1 编写一个单元测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 编写 reactive 的 happy path</span><br><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;reactive&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;happy path&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> original = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;<br>    <span class="hljs-keyword">const</span> observed = <span class="hljs-title function_">reactive</span>(original)<br>    <span class="hljs-comment">// 期望包装后和源对象不一样</span><br>    <span class="hljs-title function_">expect</span>(observed).<span class="hljs-property">not</span>.<span class="hljs-title function_">toBe</span>(original)<br>    <span class="hljs-comment">// 期望包装后某个属性的值和源对象一样</span><br>    <span class="hljs-title function_">expect</span>(observed.<span class="hljs-property">foo</span>).<span class="hljs-title function_">toBe</span>(origin.<span class="hljs-property">foo</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>那该如何实现呢？在这里我们就可以使用 Proxy + Reflect 来实现了</p><h3 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 可以使用简单的 Proxy 来实现</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">raw</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)<br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行一下 happy path，通过</p><h2 id="3-effect-实现"><a href="#3-effect-实现" class="headerlink" title="3. effect 实现"></a>3. effect 实现</h2><p>下面，我们就回过头来看看最开始的单元测试，此时我们已经有了 reactive，接下来就是去实现一个 effect API。</p><h3 id="3-1-v1-版本"><a href="#3-1-v1-版本" class="headerlink" title="3.1 v1 版本"></a>3.1 v1 版本</h3><p>首先，我们知道了 effect 接受一个参数，可以通过抽象一层：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> &#123;<br>  private <span class="hljs-attr">_fn</span>: any<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_fn</span> = fn<br>  &#125;<br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_fn</span>()<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-comment">// 抽象一层</span><br>  <span class="hljs-keyword">const</span> _effect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactiveEffect</span>(fn)<br>  <span class="hljs-comment">// 去调用方法</span><br>  _effect.<span class="hljs-title function_">run</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们 update 之前的逻辑就可以跑通了，下面的难点在于 update</p><h3 id="3-2-v2-版本"><a href="#3-2-v2-版本" class="headerlink" title="3.2 v2 版本"></a>3.2 v2 版本</h3><p>这个版本，我们主要是用于解决 update 的问题，我们来看看测试，发现在 get 操作的时候需要将依赖收集，在 set 操作的时候再去触发这个依赖，下面我们就可以手动在 reactive 中添加相应的逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">raw</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(raw, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>      <span class="hljs-comment">// 在 get 时收集依赖</span><br>      <span class="hljs-title function_">track</span>(target, key)<br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)<br>      <span class="hljs-comment">// 在 set 时触发依赖</span><br>      <span class="hljs-title function_">trigger</span>(target, key)<br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面，我们就去编写一个 track 和 trigger</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// track 相关代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveEffect</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 保存一下当前的 activeEffect</span><br>    activeEffect = <span class="hljs-variable language_">this</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_fn</span>()<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建全局变量 targetMap</span><br><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-comment">// 我们在运行时，可能会创建多个 target，每个 target 还会可能有多个 key，每个 key 又关联着多个 effectFn</span><br>  <span class="hljs-comment">// 而且 target -&gt; key -&gt; effectFn，这三者是树形的关系</span><br>  <span class="hljs-comment">// 因此就可以创建一个 WeakMap 用于保存 target，取出来就是每个 key 对应这一个 depsMap，而每个 depsMap 又是一个 Set</span><br>  <span class="hljs-comment">// 数据结构（避免保存重复的 effect）</span><br>  <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>    depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>    targetMap.<span class="hljs-title function_">set</span>(target, depsMap)<br>  &#125;<br>  <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">if</span> (!dep) &#123;<br>    dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>    depsMap.<span class="hljs-title function_">set</span>(key, dep)<br>  &#125;<br>  <span class="hljs-comment">// 将 effect 加入到 set 中</span><br>  dep.<span class="hljs-title function_">add</span>(activeEffect)<br>&#125;<br><br><span class="hljs-comment">// 需要一个全局变量来保存当前的 effect</span><br><span class="hljs-keyword">let</span> activeEffect<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面是 trigger</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-comment">// trigger 的逻辑就更加简单了，我们只需要取出对应的 deps 这个 set，再遍历执行每个 effect 就可以了</span><br>  <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">const</span> deps = depsMap.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> effect <span class="hljs-keyword">of</span> deps) &#123;<br>    effect.<span class="hljs-title function_">run</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们再跑测试，就发现通过了，现在我们已经实现了 effect、reactive 的 happy path 了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>00 - 初始化环境</title>
    <link href="/2022/03/11/0.%E5%88%9D%E5%A7%8B%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
    <url>/2022/03/11/0.%E5%88%9D%E5%A7%8B%E5%8C%96%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h1><p>本文，主要是对于开发与测试环境的初始化。在本项目中，将采用 <code>jest</code> 作为功能测试框架。使用 <code>typescript</code> 作为主要开发语言。</p><p>请按照以下步骤初始化环境：</p><h2 id="1-初始化仓库"><a href="#1-初始化仓库" class="headerlink" title="1. 初始化仓库"></a>1. 初始化仓库</h2><p>为了更好管理仓库的版本，请使用 Git 作为版本管理工具，请确保你的仓库中已初始化 Git</p><p>请确保你的仓库已经初始化 <code>package.json</code></p><p>请确保该仓库使用的包管理工具是 <code>pnpm</code></p><h2 id="2-安装必要的包"><a href="#2-安装必要的包" class="headerlink" title="2. 安装必要的包"></a>2. 安装必要的包</h2><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 typescript</span><br>pnpm add -D typescript<br><span class="hljs-comment"># 配置 tsconfig.json</span><br>npx tsc --init<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 jest @types/jest</span><br>pnpm add -D jest @types/jest<br></code></pre></td></tr></table></figure><h2 id="3-配置-npm-script"><a href="#3-配置-npm-script" class="headerlink" title="3. 配置 npm script"></a>3. 配置 npm script</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    “scripts”<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jest&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>可以通过 <code>pnpm test</code> 来运行所有的单元测试，也可以通过 VS Code 插件 <code>Jest Runner</code> 来对某一个参数单独 Debug 或 Run。</p><p>这里需要说明一下，如果使用 Jest Runner 来单独对某个测试进行 Run 的话，可能会出现报错问题（v27.5.1）这个版本会出现，解决办法如下：</p><ol><li><p>创建 <code>/.vscode/settings.json</code></p></li><li><p>将下面的代码添加到此配置文件中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;jestrunner.jestPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node_modules/jest/bin/jest.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><a href="https://github.com/facebook/jest/issues/4751">关于此问题的 issue</a></p></li></ol><h2 id="4-配置-jest-ESM-support"><a href="#4-配置-jest-ESM-support" class="headerlink" title="4. 配置 jest ESM support"></a>4. 配置 jest ESM support</h2><p>为了更好的编写测试代码，我们需要让 jest 支持 ESM。方法如下：</p><ol><li><p>安装必要的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm add -D babel-jest @babel/core @babel/preset-env @babel/preset-typescript<br></code></pre></td></tr></table></figure></li><li><p>创建 <code>bable.config.js</code>，并将下面的内容加入到配置文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">presets</span>: [<br>      [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>, &#123;<span class="hljs-attr">targets</span>: &#123;<span class="hljs-attr">node</span>: <span class="hljs-string">&#x27;current&#x27;</span>&#125;&#125;],<br>      <span class="hljs-string">&#x27;@babel/preset-typescript&#x27;</span>,<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>即可</p></li></ol><p>以上，项目初始化配置已经配完。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
